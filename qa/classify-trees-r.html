<!--#include virtual="/inc/header02.txt" -->
<title>GIS-Lab: Классификация растровых данных с помощью деревьев решений в R</title>
<!--#include virtual="/inc/header2.txt" -->
<div class="cont">
<div class="col1">

<ul class="path">
   <li class="first"><a href="/">Главная</a></li>
   <li><a href="/qa.html">Статьи</a></li>
</ul>
<!--Contents start-->
<h1>Классификация растровых данных с помощью деревьев решений в R</h1>
<p class="ann">Пошаговый разбор скрипта для классификации</p>
<p class="discuss discuss_top"><span><!--#include virtual="/scripts/forum-comments-num.php?i=6914"--></span></p>

<p>Статья рассматривает пример классификации с помощью деревьев решений. Програмная реализация - R.</p>
<p>Тематическая классификация с помощью деревьев решений состоит из трех основных этапов:</p>
<ol>
  <li>Подготовка классифицируемых (растровых) данных</li>
  <li>Сбор и подготовка тренировочных данных </li>
  <li>Классификация тренировочных данных - создание модели (дерева)</li>
  <li>Применение модели к классифицируемым данным - получение результата </li>
</ol>
<p>В этой статье подробно рассматриваются шаги 3 и 4. Чтение и запись растров подробно описывается в <a href="/qa/rgdal.html">отдельной статье</a>, здесь мы останавливаемся только на ключевых моментах. Сбор тренировочных данных полигональными профилями также описывается в <a href="/qa/extract-pixel-data.html">отдельной статье</a>, способов собрать такие данные много. В этой статье не рассматривается теория деревьев решений/регрессии. </p>
<p>Из программного обеспечения нам поднадобится пакет R для созданяи моделей и классификации. Для R нужно два дополнительных пакета: rgdal для работы с растрами и tree для создания моделей и классификации данных. Также пригодится любая ГИС для визуализации результатов.</p>
<p>Вы можете <a href="/other/classify-trees-r.7z">скачать пакет</a> с исходными, тренировочными и конечными данными использованными в данной статье.</p>
<p>Загружаем пакеты если они еще не загружены:  </p>
<pre>library(rgdal)
library(tree)
</pre>
<p>Для начала определим некоторые переменные, все они вводятся для удобства: </p>
<pre>treesfile = "c:\\temp\\trees.txt"
bnames = c("b11","b12","b13","b14","b15","b21","b22","b23","b24","b25","diff1","diff2","diff3","diff4","diff5")
b2names = c("class",bnames)
numbands = 15
</pre>
<p><em>treesfile</em> - текстовый файл, куда будет записываться служебная информация о процессе классификации и результирующая модель - дерево решений. Не обязательно.</p>
<p><em>bnames</em> - список (&quot;вектор&quot; в терминологии R) строк - названий каналов растра. Обеспечивает легкую идентификацию переменных и лучшую читабельность модели. Не обязательно.</p>
<p><em>b2names</em> - вектор <em>bnames</em>, в начало которого добавлена строка &quot;class&quot; обозначающая дополнительное поле содержащее значение класса. Не обязательно. </p>
<p><em>numbands</em> - количество каналов в классифицируемом растре, должно быть также равно количеству полей в файле тренировочных эталонов.</p>
<p>Для служебных целей запишем в <em>treesfile</em> время начала процесса:</p>
<pre>sink(file=treesfile)
	date()
sink()</pre>
<p>Загрузим и подготовим тренировочные данные, по которым будет создаваться модель: </p>
<pre>train="c:\\temp\\train.csv"
traindata = matrix(as.integer(scan(file=train)),ncol=numbands+1,byrow=T)
class=factor(traindata[,numbands+1])
trainframe=data.frame(class,traindata[,1:numbands])
names(trainframe) = b2names</pre>
<p><em>train</em> - указывает имя и путь к файлу содержащему тренировочные данные. Он представляется из себя простой текстовый файл с разделителями, где каждая запись содержит экстрагированные значения растра во всех каналах (число полей с данными равно <em>numbands</em>). Плюс к данным в файле также есть дополнительное (последнее) поле содержащее значение класса. В нашем случае это 1 (дешифрируемый феномен, сгоревшие территории) или 2 (фон, остальное). Тренировочные данные собираются вручную. Для этого могут использоваться как точечные, так и полигональные профили, как описано <a href="/qa/extract-pixel-data.html">например здесь</a>.</p>
<p align="center"><img src="/images/classify-trees-r-01.jpg" width="700" height="502"> </p>
<p>Фрагмент файла с тренировочными данными собранными таким образом выглядит так: </p>
<pre>17 151 591 358 354 146 138 33 147 161 31971 32013 32558 32211 32193 1
117 151 591 358 354 147 138 42 150 163 31970 32013 32549 32208 32191 1
117 151 591 358 354 142 133 36 146 161 31975 32018 32555 32212 32193 2
113 147 580 354 351 141 131 39 146 161 31972 32016 32541 32208 32190 2</pre>
<p><em>traindata</em> - матрица с числом колонок равным <em>numbands</em>+1 (class), создаваемая  в процессе чтения файла с тренировочными данными</p>
<p><em>class</em> - вектор данных содержащий только значения класса (единицы и двойки)</p>
<p><em>trainframe</em> - фрейм данных создаваемый небольшой переорганизацией исходных тренировочных данных, класс ставится в начало, тренировочные данные  после класса.</p>
<p>в последней операции полям фрейма с тренировочными данными назначаются благозвучные имена заданные ранее. Это позволит при рассмотрении дерева иметь дело с значащими именами а не именами по умолчанию (V1, V2...). Таким образом, если необходимости в изучени самой модели нет, то этот шаг можно опустить.</p>
<pre>image = "c:\\temp\\input.tif"
x = new("GDALReadOnlyDataset", image)
width = dim(x)[2]
height = dim(x)[1]
imagedata = data.frame(getRasterTable(x)[3:(numbands+2)])
names(imagedata) = bnames</pre>
<p><em>image</em> - имя и путь к классифицируемому (исходному) растру</p>
<p><em>x</em> - объект GDAL содержащий указатель на растр</p>
<p><em>width</em>, <em>height</em> - количество колонок, строк в исходном растре. </p>
<p><em>imagedata</em> - данные растра, первые два массива getRasterTable(x)[1:2], представляют собой массив координат центров пикселей, широту и долготу соответственно и, таким образом в классификации не участвуют и индекс последнего канала смещается на 2.</p>
<p>Последняя операция опять же делает &quot;красивыми&quot; названия полей во фрейме, так как в исходном растре поля class нет, то применяется bnames, не содержащая class.</p>
<pre>numrows=length(trainframe[,1])
indexAll=1:numrows

numtrees=30
step=0.5</pre>
<p><em>numrows</em> - количество элементов в тренировочных данных, равно количеству пикселей, т.е. можно было бы также получить умножив ширину на высоту.</p>
<p><em>indexAll</em> - индекс (последовательность) от 1 до numrows.</p>
<p><em>numtrees</em> - количество деревьев или сколько раз будет производиться создание модели-дерева по тренировочным данным. Мы собираемся произвести классификацию не один, а <em>numtrees</em> раз, каждый раз выбирая случайную часть набора тренировочных данных и далее усредняя результат, т.н. bagging. </p>
<p><em>step</em> - какая выборка (доля от 1) тренировочных данных при этом будет выбираться для каждого дерева. </p>
<p>Блок программы выполнящий основную работу выглядит следующим образом: </p>
<pre>ans1 = 0
for(i in 1:numtrees) {
	sampledata=sample(indexAll,numrows*step,replace=T)
	testdata=trainframe[sampledata,]

	atree=tree(class ~.,data=testdata,mindev=0,minsize=1)
	B=predict.tree(atree,newdata=imagedata,type="vector")

	ans1 = ans1 + B[,1]
	print(paste("Processing tree#: ",i))
	sink(file=treesfile,append = T)
        print(summary(atree))
	sink()
}
ans1=100*ans1/numtrees</pre>
<p>Для каждого из деревьев (которых у нас 30), делается выборка данных <em>sampedata</em>, берется 50% тренировочных данных. На основе этих данных строится дерево решений <em>atree</em>. Потом это дерево применяется к самому снимку. Результат классификации снимка - вектор из 0 и 1, длиной равной количеству пикселей в растре, прибавляется сам к себе. Таким образом, результат, хранящийся в переменной <em>ans1</em> показывает сколько из 30 деревьев определили пиксель как принадлежащий к классу 1, а сколько к классу 2. </p>
<p>Последняя часть в цикле сбрасывает сами деревья в служебный файл для последующего обучения. Эта информация может быть полезна например для определения, какие переменные (каналы) вносили наибольший вклад в разделение классов. Пример выводимых данных:</p>
<pre>Classification tree:
tree(formula = class ~ ., data = testdata, mindev = 0, minsize = 1)
Variables actually used in tree construction:
[1] "b23"   "b11"   "diff3" "b12"  
Number of terminal nodes:  5 
Residual mean deviance:  0 = 0 / 393 
Misclassification error rate: 0 = 0 / 398</pre>
<p>В конце происходит перевод полученных частот в проценты.</p>
<p>Наконец, результат нужно сохранить в выходной растровый файл (output.tif), эта часть подробно описывается в статье &quot;<a href="/qa/rgdal.html">Работа с растровыми данными в R: rgdal</a>&quot; и останавливаться подробно на ее разборе мы не будем. </p>
<pre>tif_driver <- new("GDALDriver", "GTiff")
tif2 <- new("GDALTransientDataset", tif_driver, height, width, 1, 'Byte')
resmtx = matrix(ans1,width,height)
bnd1 <- putRasterData(tif2, resmtx)
tif_file = "c:\\temp\\output.tif"
saveDataset(tif2, tif_file)
GDAL.close(tif2)
GDAL.close(tif_driver)</pre>
<p>Результат получен, теперь нужно загрузить его поверх исходного многоканального изображения и убедиться, что классификация прошла нормально. Разумеется, более точно о качестве классификации можно судить только имея независимый источник для валидации, по которому можно рассчитать ошибки комиссии и омиссии, а также общую точность. Подробнее это рассматривается в статье &quot;<a href="/qa/error-matrix.html">Матрица ошибок и расчет показателей точности тематических карт</a>&quot;. </p>
<p>Необходимо также помнить, что, так как наш результат представляет собой диапазон значений от 0 до 100, то перед нами стоит проблема как выбрать порог отсечения. Другими словами, какое число деревьев должно было отнести пиксел к определенному классу, чтобы мы сочли его действительно принадлежащим этому классу. Самая простая стратегия здесь - правило большинства, т.е. пиксель считается относящимся к некоторому классу, если больше чем 50% деревьев отнесло его к этому классу. Конечно, здесь могут быть и более подходящие для ситуации стратегии. </p>
<p align="center"><img src="/images/classify-trees-r-02.jpg" width="700" height="502"></p>
<p>Полную версию скрипта для классификации можно скачать <a href="/other/classify-trees-r.7z">в комплекте с исходными данными</a>.</p>
<!-- обсуждение на форуме, цифра изменяется при публикации статьи -->   
<p class="discuss"><span><!--#include virtual="/scripts/forum-comments-num.php?i=6914"--></span></p>
<!-- ссылки -->
<div class="links">
	<h2>Ссылки по теме</h2>
		<ul>
			<li><a href="/qa/imagesvm.html">Классификация данных ДЗЗ используя метод опорных векторов и imageSVM</a><a href="http://lpdaac.usgs.gov/landdaac/tools/modis/about.asp" target="_blank" class="external"></a></li>
			</ul>
</div>
<!--Contents end-->
<!--#include virtual="/scripts/date.php" -->
<p class="status"><span>Дата создания: 06.01.2011
<br>
Автор(ы): <a href="/forum/memberlist.php?mode=viewprofile&u=2" target="_blank">Максим Дубинин</a></span></p>
<!--#include virtual="/inc/footer2.php" -->
