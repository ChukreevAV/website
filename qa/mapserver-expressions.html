<!--#include virtual="/inc/header02.txt" -->
<title>GIS-Lab: Выражения в MapServer</title>
<!--#include virtual="/inc/header2.txt" -->
<!--Contents start-->
<div class="cont">
<div class="col1">

<ul class="path">
   <li class="first"><a href="/">Главная</a></li>
   <li><a href="/qa.html">Вопросы и ответы</a></li>
</ul>
<h1>Выражения в MapServer</h1>
<p class="ann">Описаны виды выражений, используемых в MapServer для фильтрации данных и классификации объектов.</p>
<p class="discuss discuss_top"><span><!--#include virtual="/scripts/forum-comments-num.php?i=1997"--></span></p>
            <p><strong>Введение</strong></p>
            <p>Выражения являются одной из наиболее часто используемых в MapServer структур  и используются в нескольких целях:
            <ol>
                  <li>для фильтрации (предложение FILTER) данных в слоях (предложение LAYER) и классах (предложение CLASS)</li>
                  <li>для определения классов (предложение EXPRESSION в определении класса)</li>
                  <li>для формирования запросов MapServer (cgi переменная QSTRING, передаваемая в строке адреса)</li>
            </ol>
            <p>Выражения MapServer бывают трех видов:
            </p>
            <ol>
                  <li>основанные на простом сравнении строк</li>
                  <li>основанные на регулярных выражениях</li>
                  <li>основанные на логических выражениях</li>
            </ol>
            <p>В основу статьи легла англоязычная документация, доступная <a href="http://mapserver.gis.umn.edu/docs/howto/msexpressions" target="_blank"
              class="external">на официальной странице Mapserver</a></p>
            <p><strong>Оглавление</strong></p>
            <ol>
                  <li><a href="#01">Сравнение строк</a></li>
                  <li><a href="#02">Регулярные выражения</a></li>
                  <li><a href="#03">"Выражения MapServer"</a></li>
                  <li><a href="#04">Ссылки на атрибуты в выражениях</a></li>
            </ol>
                <p><strong><img src="/images/1.gif" alt="1" width="33" height="41" align="left" /><a name="01" id="01"></a>Сравнение строк</strong></p>
                  <p>Этот тип выражений является наиболее простым: атрибут объекта проверяется на совпадение с заданной строкой. Если вы используете сравнение строк для фильтрации данных некоторого слоя, то необходимо указать предложения FILTERITEM и FILTER:
                  </p>
                  <tcode>
FILTER "RING"           # отбрасываем все записи, не равные "RING"
<br />
FILTERITEM "TYPE"       # ищем совпадение с "RING" в поле "TYPE"                      </tcode>
                  <p>Аналогично с использованием сравнения строк при фильтрации в предложении CLASS - также необходимо указать и FILTERITEM, и FILTER.
                  </p>
                  <p>Сравнение строк в выражении EXPRESSION:
                  </p>
                  <p>В предложении LAYER нужно указать поле базы данных, по которому будет производиться поиск, а в определении класса - само выражение EXPRESSION:
                  </p>
                  <pre>
LAYER
  NAME "RingsRet"
  CLASSITEM "TYPE"
  ...
    CLASS
      NAME "Rings"
      EXPRESSION "RING"
      ...
    END
END</pre>
                  <p>Замечание: выражения EXPRESSION и FILTER не могут начинаться с символов "(" и "/".
                  </p>


                  <p><img src="/images/2.gif" alt="2" width="33" height="41" align="left" /><strong><a name="02" id="02"></a>Регулярные выражения</strong></strong></p>

                  <p>Регулярные выражения - обычный способ сравнения строк, используемый в UNIX. А поскольку MapServer использует для вычисления регулярных выражений  процедуры операционной системы, то на разных UNIX-платформах могут быть различия в результатах использовании регулярных выражений.  Несмотря на различия, все-таки можно привести часть сведений, представляющую  что-то вроде "общего знаменателя".                  </p>

                  <p>Итак, регулярные выражения в MapServer работают аналогично сравнению строк, но представляют более широкие возможности. Регулярные выражения работают  медленнее, чем простое сравнение строк, но зато они могут быть более быстрыми, чем логические выражения. В зависимости от того, где будут использованы регулярные выражения (FILTER или EXPRESSION), нужно задать значения соответствующего параметра FILTERITEM или CLASSITEM.                  </p>

                  <p>Регулярное выражение содержит наряду с обычными символами символы, которые интерпретируются особым образом. Например, если символы русского или латинского алфавитов (А-Я, a-z) или цифры (0-9) воспринимаются при разборе выражения программой-анализатором как обычный символ, то символ точки (.) будет воспринят специальным образом.
                  </p>

                  <p>Значения специальных символов:
            <ol>
                      <li>"."  Точка означает любой символ (один).</li>
                      <li>"[" и "]"    Используются для группировки. Например, появление в регулярном выражении последовательности [А-Я] подразумевает, что в этом месте может стоять любой из символов А,Б,В,...Э,Ю,Я.</li>
                      <li>* Любое количество символов </li>
                      <li>"^"        Помечает начало строки.</li>
                      <li>"$"        Помечает конец строки.</li>
                      <li>"\"        Используется для того,  чтобы указать, что последующий специальный символ нужно понимать буквально. Например, \$ означает знак доллара.</li>
            </ol>
                  <p>
                    Пример 1. В следующем слое будут содержаться только те объекты, строковый атрибут которых содержит подстроку "ANSER" в поле NAME , например "ANSER ALBIFRONS".
                  </p>
                  <pre>
LAYER
  NAME "Anser"
  FILTERITEM "NAME"
  FILTER /ANSER/
  ...
END</pre>
                  <p>Нужно отметить, что регулярные выражения чувствительны к регистру символов, поэтому в слое "Anser" не будут содержаться объекты с атрибутом NAME, равным "anser" (первая буква - не заглавная) .
                  </p>
                  <p>Пример 2. Отфильтровать те записи, поле "год" которых содержит значения текущего столетия (например, 2007).
                  </p>
                  <tcode>
FILTERITEM "year"
<br />
FILTER /^20[0-9][0-9]/                      </tcode>
                  <p>Пример 3. Отфильтровать те записи, которые содержат только числа или не содержат вообще никаких данных.
                  </p>
                  <tcode>
FILTER /^[0-9]*$/
                      </tcode>
                <p><img src="/images/3.gif" alt="3" width="33" height="41" align="left" /><strong><a name="3" id="03"></a>"Выражения MapServer"</strong></p>
                 <p>
                   Выражения MapServer обладают более широкими возможностями по сравнению с рассмотренными ранее способами фильтрации данных,  однако, они являются и более медленными. Такие выражения могут сравнивать несколько атрибутов одновременно и производить фильтрацию или классификацию по этим атрибутам.
            </p>
                  <p>
                    Кроме собственно логических выражений, MapServer поддерживает также операции над числовыми и строковыми величинами. Однако,
                    для того, чтобы можно было использовать выражения MapServer в предложениях
                    FILTER или EXPRESSION, необходимо, чтобы выражение в целом имело логическое значение.
                  </p>

                  <p><strong>Логические выражения</strong>
                  </p>
                  <p>Логические выражения - это выражения, которые могут принимать только два возможных значения - истина или ложь (true или false).
                    В MapServer логическое выражение всегда должно быть заключено в круглые скобки. Логическое выражение может состоять из нескольких других логических выражений.
                    В этом случае используются логические операции,  получающие на входе одно логическое выражение и выдающие на выходе другое.
                  </p>
                  <p>Примеры использования логических операций и выражений:
                  </p>

                  <p>Логическое "и" (две эквивалентных формы записи) :
                  </p>
                  <tcode>
( ( ... ) AND ( ... ) )<br />
( ( ... ) && ( ... ) )                      </tcode>
                  <p>будет истинным лишь в том случае, когда истинны оба выражения, входящих в него.
                  </p>

                  <p>Логическое "или" (две эквивалентных формы записи):                  </p>
                  <tcode>
( ( ... ) OR ( ... ) )
  <br />
  ( ( ... ) || ( ... ) )                      </tcode>
                  <p>будет истинным лишь в том случае, если истинно хотя бы одно из составляющих его выражений.
                  </p>

                  <p>Логическое отрицание (две эквивалентных формы записи):                  </p>
                  <tcode>
NOT ( ... )
  <br />
  ! ( ... )                      </tcode>
                  <p>будет истинным, если ложно выражение в скобках.
                  </p>
                  <p><strong>Строковые операции</strong>
                  </p>
                  <p>Синтаксически, строка в MapServer представляет собой любой набор символов, содержащийся в двойных кавычках.
                  </p>

                  <p><strong>Строковые операции, возвращающие логическое значение</strong>
                  </p>

                  <p>Равенство строк (три эквивалентных формы записи):                  </p>
                  <tcode>
( "String1" eq "String2" )
<br />
( "String1" == "String2" )<br />
( "String1" = "String2" )                      </tcode>
                  <p>Они вернут истину, если строки равны между собой (совпадают).
                  </p>

                  <p>Сравнение строк на неравенство (две эквивалентных формы записи):                  </p>
                  <tcode>
( "String1" != "String2" )<br />
( "String1" ne "String2" )                      </tcode>
                  <p>На выходе - истина, если строки не совпадают.
                  </p>
                  <p>Сравнение строк:</p>
                  <tcode>
( "String1" < "String2" )<br />
( "String1" lt "String2" )                      </tcode>
                  <p>Вернет истину, если первая строка лексикографически меньше, чем вторая.
                  </p>

                  <tcode>
( "String1" > "String2" )
<br />
( "String1" gt "String2" )</tcode>
                  <p>Вернет истину, если первая строка лексикографически больше,  чем вторая.
                  </p>
                  <tcode>
( "String1" <= "String2" )<br />
( "String1" le "String2" )                      </tcode>
                  <p>Вернет истину, если первая строка не больше второй.
                  </p>

                  <tcode>
( "String1" >= "String2" )<br />
( "String1" ge "String2" )                      </tcode>
                  <p>Вернет истину, если вторая строка не больше первой.
                  </p>

                  <tcode>
( "String1" IN "token1,token2,...,tokenN" )
                      </tcode>
                  <p>Вернет истину, если String1 совпадает с одним из заданных токенов
                   (подстрок). Токены отделяются друг от друга запятыми, поэтому нет необходимости
                   добавлять лишние пробелы. По этой же причине таким способом нельзя сравнивать строки, содержащие запятые.
                  </p>

                  <tcode>
( "String1" =~ /regexp/ )
                      </tcode>
                  <p>Вернет истину, если String1 совпадает (по шаблону) с регулярным выражением. Эта операция эквивалентна вышеописанной операции сравнения по регулярному выражению.
                  </p>
                  <p><strong>Строковые операции, возвращающие строковые значения.</strong>
                  </p>
                  <p>На данный момент (MapServer 4.x) есть только одна операция, возвращающая сторковое выражение - конкатенация (сложение) строк. Значением выражения
                  </p>
                  <tcode>
"String1" + "String2"
                      </tcode>
                  <p>будет строка</p>

                  <tcode>
"String1String2"
                      </tcode>

                  <p><strong>Операции над числовыми значениями.</strong>
                  </p>

                  <p><strong>Арифметические операции, возвращающие логическое значение.</strong>
                  </p>

                  <p>Здесь все очевидно.
                  </p>

                  <tcode>
( n1 eq n2 )
  <br />
  ( n1 == n2 )
  <br />
  ( n1 = n2 )                      </tcode>
                  <p>Вернет истину, если числа равны.
                  </p>


                  <tcode>
( n1 != n2 )<br />
( n1 ne n2 )                      </tcode>
                  <p>Вернет истину, если числа не равны.
                  </p>

                  <tcode>
( n1 < n2 )
<br />
( n1 lt n2 )                      </tcode>
                  <p>Вернет истину, если первое число меньше второго.
                  </p>

                  <tcode>
( n1 > n2 )<br />
( n1 gt n2 )                      </tcode>
                  <p>Вернет истину,если первое число больше второго.
                  </p>

                  <tcode>
( n1 <= n2 )<br />
( n1 le n2 )                      </tcode>
                  <p>Вернет истину, если первое число меньше или равно второму.
                  </p>

                  <tcode>
( n1 >= n2 )<br />
( n1 ge n2 )                      </tcode>
                  <p>Вернет истину, если перевое число больше или равно второму.
                  </p>

                  <tcode>
( n1 IN "number1,number2,...,numberN" )
                      </tcode>
                  <p>Вернет истину, если n1 равно одному из перечисленных чисел.
                  </p>


                  <p><strong>Арифметические операции, возвращающие число.</strong>
                  </p>

                  <p>Сумма:
                  </p>
                  <tcode>
n1 + n2
                      </tcode>
                  <p>Разность:
                  </p>
                  <tcode>
n1 - n2
                      </tcode>
                  <p>Произведение:
                  </p>
                  <tcode>
n1 * n2
                      </tcode>
                  <p>Частное:
                  </p>
                  <tcode>
n1 / n2
                      </tcode>
                  <p>Изменение знака:
                  </p>
                  <tcode>
-n1
                      </tcode>
                  <p>Возведение в степень:
                  </p>
                  <tcode>
n1 ^ n2
                      </tcode>
                  <p>вернет n1 в степени n2.
                  </p>
                  <p>Вычисление длины строки:
                  </p>
                  <tcode>length ( "String1" )
                      </tcode>
                  <p>вернет число символов в строке  String1.
                  </p>
                  <p>Замечание. Числовые операции могут быть использованы в качестве логических операций по следующему правилу: если результат числовой операции равен нулю, то считается, что выражение вернуло "ложь" при любом ненулевом значении - выражени вернуло "истину".
                  </p>
                  <p>Пример.
                  </p>
                  <tcode>( 6 + 5 )
                      </tcode>
                  <p>означает истину, а                </p>
                 <tcode>( 5 - 5 )
                      </tcode>
                  <p>означает ложь.</p>
                  <p><strong>Выражения над датами и временем.</strong>
                  </p>
                  <p>MapServer для сравнения дат и времени использует свой внутренний формат. Чтобы выполнить преобразование в этот формат, MapServer пытается сравнить вид полученного значения с видом из следующего списка, просматривая список сверху вниз. В случае совпадения, производится преобразование:
                  </p>

                  <tcode>
YYYY-MM-DDTHH:MM:SSZ
  <br />
  YYYY-MM-DDTHH:MM:SS
  <br />
  YYYY-MM-DD HH:MM:SS
  <br />
  YYYY-MM-DDTHH:MM
  <br />
  YYYY-MM-DD HH:MM<br />
YYYY-MM-DDTHH
  <br />
  YYYY-MM-DD HH
  <br />
  YYYY-MM-DD
  <br />
  YYYY-MM
  <br />
  YYYY
  <br />
  THH:MM:SSZ
  <br />
  THH:MM:SS                      </tcode>


                  <p>Для преобразованных во внутренний формат значений времени (даты) возможны следующие операции, которые аналогичны операциям, рассмотренным выше:
                  </p>

                  <tcode>
1)
  <br />
  ( n1 eq n2 )<br />
( n1 == n2 )
<br />
( n1 = n2 )
<br />
2)<br />
( t1 != t2 )<br />
( t1 ne t2 )
<br />
3)
<br />
( n1 < n2 )
<br />
( n1 lt n2 )<br />
4)<br />
( n1 > n2 )
<br />
( n1 gt n2 )<br />
5)<br />
( t1 <= t2 )<br />
( t1 le t2 )<br />
6)<br />
( n1 >= n2 )
<br />
( n1 ge n2 )                      </tcode>



              <p><img src="/images/4.gif" alt="4" width="33" height="41" align="left" /><strong><a name="04" id="04"></a>Ссылки на атрибуты в выражениях</strong></p>

              <p>При использовании атрибутов в выражениях MapServer, принято следующая номенклатура: название поля (название атрибута) заключается в квадратные скобки, например, [TYPE]. При анализе выражения MapServer вместо названия атрибута подставляет его значение.              </p>
              <p>Пример. Обычное сравнение строк может быть выполнено следующим образом:
              </p>

              <tcode>FILTER ( "[TYPE]" == "RING" )</tcode>
              <p>Для растровых слоев доступны следующие специальные атрибуты:</p>

              <p>[PIXEL] (при анализе заменится на числовое выражение, представляющее цвет), а также [RED], [GREEN], [BLUE] - цветосоставляющие компоненты.
              </p>
            <p class="discuss">
				<span><!--#include virtual="/scripts/forum-comments-num.php?i=1997"--></span>
			</p>
			<div class="links">
			<h2>Ссылки по теме</h2>
			<ul>
               <li><a href="mapserver.html">Создание картографических сервисов с использованием MapServer. Введение</a></li>
			   <li><a href="mapserver-install.html">Установка MapServer для Windows</a></li>
			   <li><a href="mapserver-begin.html">Начало работы с MapServer</a></li>
			</ul>
			</div>
<!--Contents end-->
<!--#include virtual="/scripts/date.php" -->
<p class="status"><span>Дата создания: 04.01.2008
<br>Автор(ы): <a href="/forum/memberlist.php?mode=viewprofile&u=6597" target="_blank">Дмитрий Колесов</a></span></p>
<!--#include virtual="/inc/footer2.php" -->
