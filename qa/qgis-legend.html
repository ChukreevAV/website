<!--#include virtual="/inc/header02.txt" -->
<title>GIS-Lab: Список слоёв для приложений PyQGIS</title>
<!--#include virtual="/inc/header2.txt" -->
<div class="cont">
<div class="col1">

<ul class="path">
   <li class="first"><a href="/">Главная</a></li>
   <li><a href="/qa.html">Вопросы и ответы</a></li>
</ul>
<!--Contents start-->
<h1>Добавление списка слоёв в приложение PyQGIS</h1>
<p class="ann">Подробное описание процесса подключения списка слоёв в приложениях на базе QGIS с помощью Python</p>
<p class="discuss discuss_top"><span><!--#include virtual="/scripts/forum-comments-num.php?i=7211"--></span></p>

<p>QGIS помимо готовой пользовательской ГИС является еще и набором библиотек, которые могут быть использованы
для создания новых приложений. Мы уже <a href="qgis-standalone.html">рассказывали</a>
о создании самостоятельного отдельного приложения на основе QGIS. К сожалению,
при разработке таких приложений некоторые элементы интерфейса необходимо
создавать самостоятельно. Один из примеров такого элемента - список
загруженных слоёв (иногда неверно называемый легендой).</p>

<p>Данная статья описывает процесс встраивания списка слоёв в приложение PyQGIS.
В основе статьи лежит перевод поста &laquo;<a href="http://geotux.tuxfamily.org/index.php?option=com_myblog&show=tabla-de-contenido-leyenda-para-aplicaciones-basadas-en-pyqgis.html&Itemid=59" target="_blank" class="external">Layer list widget for PyQGIS
applications</a>&raquo;, сделанного German Carrillo в блоге GeoTux.</p>

<p>Работоспособность примеров проверена на QGIS 1.7. В новых версиях QGIS
могут быть внесены изменения, делающие данные примеры неработоспособным.</p>

<p><strong>Оглавление</strong></p>
<ol>
  <li><a href="#01">Подготовка</a></li>
  <li><a href="#02">Общие сведения о виджете</a></li>
  <li><a href="#03">Подключение легенды к приложению</a></li>
</ol>

<!-- Первый раздел -->
<h2><strong><a name="01" id="01"></a></strong>1. Подготовка</h2>
<p>Будем исходить из того, что все программное обеспечение установлено при
помощи установщика OSGeo4W (<a href="qgis-osgeo4w.html">подробнее</a>)
используя путь по умолчанию C:\OSGeo4W. Кроме самой QGIS со всеми
зависимостями, необходимо выбрать следующие пакеты в категории Libs:</p>
<pre>pyqt4, qt4-devel, qt4-doc, qt4-libs</pre>
<p>В этих пакетах находятся инструменты разработчика, необходимые библиотеки
и документация.</p>
<p>Предполагается, что читатель уже знаком с процессом создания приложений
PyQGIS и QGIS Python API. Если это не так, рекомендуем ознакомиться
со статьей &laquo;<a href="qgis-standalone.html">Создание приложения на базе
набора библиотек QGIS на Python</a>&raquo;. Для демонстрации основных аспектов
работы со списком слоёв мы немного модифицировали пример, рассмотренный в этой
статье. Скачать полный код приложения можно <a href="/other/qgis-legend.7z">здесь</a>.</p>

<h2><strong><a name="02" id="02"></a></strong>2. Общие сведения о виджете</h2>
<p>Рассматриваемый виджет разработан German Carrillo и является упрощенной
версией списка слоёв QGIS. Основное отличие от оригинала&nbsp;&mdash; не
поддерживается новая символика и отсутствуют группы слоёв.</p>
<p>Вот так выглядит приложение со списком слоёв:</p>
<p align="center"><img src="/images/qgis-legend-01.png" alt="Приложение со списком слоёв" width="737" height="450"/></p>

<h3>Возможности</h3>
<ul>
  <li>получение упорядоченного списка слоёв</li>
  <li>изменение порядка следования слоёв в легенде с соответствующим изменением
  порядка слоёв карты</li>
  <li>управление видимостью слоя</li>
  <li>отображение/изменение символики слоя (рекомендуется создать свой
  собственный диалог настройки символики, автор виджета предлагает лишь
  очень простой пример)</li>
  <li>изменение некоторых параметров слоя</li>
  <li>загрузка/сохранение стилей (.qml)</li>
  <li>удаление слоёв</li>
  <li>интеграция с картой и инструментами, действующими на загруженные слои
  (Скрыть/Показать все, Удалить все)</li>
</ul>
<p>Виджет распространяется по условиям <a href="http://www.gnu.org/licenses/gpl-2.0.html">GNU GPL v2</a>.</p>

<h2><strong><a name="03" id="03"></a></strong>3. Подключение легенды к приложению</h2>
<p>Сначала нужно загрузить <a href="http://downloads.tuxfamily.org/tuxgis/geoblogs/pyqgis_toc/pyqgis_legend.zip" target="_blank" class="external">архив</a>
и извлечь его содержимое в каталог с приложением. В архиве находится</p>
<ul>
  <li>файл legend.py, который реализует весь фукционал легенды</li>
  <li>несколько иконок, необходимых для отображения слоёв разных типов</li>
  <li>иконки действий для выпадающего меню</li>
  <li>диалог настройки свойств слоя</li>
</ul>

<h3>Инициализация</h3>
<p>В основном классе нашего приложения импортируем класс Legend из файла
legend.py </p>
<pre>from legend import Legend</pre>

<p>В этом же классе создадим новый метод CreateLegendWidget, который будет
отвечать за создание плавающего окна и за установку связи между легендой
и картой.</p>
<pre>
def createLegendWidget( self ):
  # создаем легенду
  self.legend = Legend( self )
  self.legend.setCanvas( self.canvas )
  self.legend.setObjectName( "theMapLegend" )

  # создаем плавающую панель и добавляем к ней легенду
  self.LegendDock = QDockWidget( "Layers", self )
  self.LegendDock.setObjectName( "legend" )
  self.LegendDock.setAllowedAreas( Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea )
  self.LegendDock.setWidget( self.legend )
  self.LegendDock.setContentsMargins ( 9, 9, 9, 9 )
  self.addDockWidget( Qt.LeftDockWidgetArea, self.LegendDock )
</pre>
<p>Вызов этого метода необходимо добавить в метод __init__ основного
класса приложения. Обратите внимание, что создание легенды необходимо
выполнять после создания карты (QgsMapCanvas).</p>
<pre>
class MainWindow( QMainWindow, Ui_MainWindow ):
  def __init__( self ):
    MainWindow.__init__( self )

    # Требуется Qt4 для инициализации пользовательского интерфейса
    self.setupUi( self )
    # Создаем карту
    self.canvas = QgsMapCanvas()
    ...
    # создаем легенду
    self.createLegendWidget()
</pre>

<h3>Использование</h3>
<p>Виджет легенды использует несколько иконок: иконки для разных типов
слоёв и иконки для контекстного меню слоя. Чтобы они отображались
необходимо скомпилировать входящий в архив файл resources.qrc командой</p>
<pre>pyrcc4 resources.qrc -o resources_rc.py </pre>
<p>В файле legend.py уже присутствует ссылка на сгенерированный таким
образом файл. Если приложение использует свой собственный ресурсный файл
(а так чаще всего и бывает), есть два варианта</p>
<ol>
  <li>переименовать один из ресурсных файлов</li>
  <li>поместить все ресурсы в один файл</li>
</ol>
<p>В последнем случае может потребоваться задание раздельных префиксов
для ресурсов, относящихся к разным частям приложения (например, один
префикс для иконок легенды и второй для остальных файлов). При
изменении префикса для ресурсов легенды также необходимо соответствующим
образом изменить переменную resource_prefix в файле legend.py</p>
<pre>resources_prefix = ":/legend/imgs/"</pre>
<p>Мы выбрали второй вариант: все изображения находятся в каталоге images
и вложенных каталогах, в ресурсном файле создано два префикса и соотвественно
изменена переменная resource_prefix в файле legend.py. Обратите внимание,
что помимо задания другого префикса, для каждого файла был создан псевдоним
(alias).</p>

<p>При использовании легенды немного меняется процедура добавления слоёв.
Если раньше для загрузки и отображения слоя мы использовали свой собственный
метод, в котором добавляли слой и обновляли LayerSet, то теперь контролировать
процесс загрузки и удаления будет виджет легенды. Виджет имеет слот,
обновляющий список слоёв при каждом добавлении, удалении или перемещении
слоя. Всё что от нас требуется&nbsp;&mdash; вызвать соответствующие методы
класса QgsMapLayerRegistry (например, addMapLayer или removeMapLayer).
А вот вызов метода setLayerSet класса QgsMapCanvas теперь не нужен, т.к.
об этом заботится виджет легенды. Его можно закомментировать или вообще
удалить. Таким образом, для добавления нового слоя необходима всего одна
строка кода</p>
<pre>QgsMapLayerRegistry.instance().addMapLayer( layer )</pre>
<p>здесь layer&nbsp;&mdash; экземпляр класса QgsVectorLayer или
QgsRasterLayer, подробнее об этом можно прочесть в
<a href="qgis-standalone">предыдущей статье</a>.</p>

<p>Вместе в легендой поставляется простой диалог свойств слоя. Чтобы им
можно было пользоваться, необходимо скомпилировать файл dlgLayerProperties.ui</p>
<pre>pyuic4 dlgLayerProperties.ui -o dlgLayerProperties_ui.py</pre>
<p>Диалог позволяет задать имя слоя, изменить отображаемое поле и настраивать
видимость в пределах масштаба. Если этого функционала не достаточно, можно,
взяв за основу существующий диалог, разработать свой вариант.</p>
<p align="center"><img src="/images/qgis-legend-02.png" alt="Свойства слоя" width="323" height="304"/></p>

<p>При смене активного слоя виджет легенды испускает сигнал activeLayerChanged,
который можно использовать для активации/деактивации определенных инструментов
приложения, например, в зависимости от типа слоя (растр или вектор). Для
этого необходимо в главном классе приложения связать сигнал со слотом,
который и будет отвечать за активацию/деактивацию инструментов или выполнять
какие-то другие действия. Например, так</p>
<pre>
self.connect( self.legend, SIGNAL( "activeLayerChanged" ), self.enableTools )

def enableTools( self ):
  if not self.legend.activeLayer():
    # нет активного слоя, деактивируем инструменты общего назначения
  else:
    # делаем инструменты общего назначения доступными

    layerType = self.legend.activeLayer().layer().type()
    if layerType == 0: # Vector Layer
      # активируем инструменты для работы с вектором и деактивируем остальные
    elif layerType == 1: # Raster Layer
      # активируем инструменты для работы с растром и деактивируем остальные
</pre>

<p>Также виджет предоставляет несколько полезных методов, с помощью которых
можно</p>
<ul>
  <li>перебрать все слои<br>
  <pre>
  for layer in self.legend.layers:
    # сделать что-то со слоем</pre>
  </li>
  <li>скрыть или отобразить все слои<br>
  <pre>
  def showAllLayers( self ):
    self.legend.setStatusForAllLayers( True )</pre>
  </li>
  <li>получить активный слой<br>
  <pre>
  return self.legend.activeLayer()</pre>
  </li>
  <li>обновить символику слоя<br>
  <pre>
  self.legend.refreshLayerSymbology( layer )</pre>
  </li>
  <li>удалить слои по идентификаторам<br>
  <pre>
  self.legend.removeLayers( layerIds )</pre>
  </li>
</ul>
<p>Разумеется, это далеко не полный список методов рассматриваемого виджета.
Более полное представление о его возможностях можно получить заглянув в
файл legend.py, код достаточно прозрачный и снабжен комментариями, так что
разобраться в нем не составит труда.</p>

<p>На этом знакомство с виджетом легенды будем считать оконченным. Многое
осталось за бортом: например, не были затронуты вопросы настройки символики,
расширения диалогового окна свойств слоя, взаимодействие легенды и
инструментов карты... Возможно, если тема окажется интересной, статья
получит продолжение.</p>

<p>Исходные коды примера, а так же все необходимые изображения
и тестовый набор данных можно скачать <a href="/other/qgis-legend.7z">одним файлом</a>.</p>
<p>Необходимо отметить, что существует еще один вариант легенды, созданный
Aaron Racicot для проекта <a href="http://svn.infodrizzle.org/openocean/trunk/openoceanmap/Tools/legend.py">OpenOceanMap</a> и основанный на элементе управления <a href="http://doc.qt.nokia.com/4.6/qcheckbox.html">QCheckBox</a>,
а не на <a href="http://doc.qt.nokia.com/4.6/qtreewidget.html">QTreeWidget</a>.</p>
<p class="discuss"><span><!--#include virtual="/scripts/forum-comments-num.php?i=7211"--></span></p>

<div class="links">
<h2>Ссылки по теме</h2>
<ul>
   <li><a href="qgis-standalone.html">Создание приложения на базе набора библиотек QGIS на Python</a></li>
   <li><a href="http://geotux.tuxfamily.org/index.php?option=com_myblog&task=view&id=270&Itemid=59&lang=en" target="_blank" class="external">Layer list widget for PyQGIS
applications</a></li>
</ul>
</div>
<!--Contents end-->
<!--#include virtual="/scripts/date.php" -->
<p class="status"><span>Дата создания: 14.02.2011
<br>Автор(ы): <a href="forum/memberlist.php?mode=viewprofile&u=5325" target="_blank">Александр Бруй</a></span></p>
<!--#include virtual="/inc/footer2.php" -->
