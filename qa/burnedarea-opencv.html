<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
 
<!--#include virtual="/inc/header02.txt" -->
<title>GIS-Lab: Распознавание сгоревших территорий с помощью деревьев решений и OpenCV</title>
<!--#include virtual="/inc/header2.txt" -->
<div class="cont">
<div class="col1">

<ul class="path">
   <li class="first"><a href="/">Главная</a></li>
   <li><a href="/qa.html">Статьи</a></li>
</ul>
<!--Contents start-->
<h1>Распознавание сгоревших территорий с помощью деревьев решений и OpenCV</h1>
<p class="ann">Использование OpenCV для работы со снимками MODIS и их классификации</p>
<p class="discuss discuss_top"><span><!--#include virtual="/scripts/forum-comments-num.php?i=7554"--></span></p>

<p>Лето 2010 года наглядно показало, что для нас с вами очень актуальна проблема природных пожаров. Для устранения их последствий необходимо знать, на каких именно территориях они произошли, знать их точное пространственное расположение. Один из перспективных подходов к решению этой задачи &mdash; классификация территорий с помощью <a href="http://www.basegroup.ru/library/analysis/tree/description/">деревьев решений</a> по <a href="modislandprod.html">данным MODIS &ndash; Land</a>. Для эффективной обработки растровых данных и их классификации хорошо подходит библиотека компьютерного зрения <a href="http://opencv.willowgarage.com/">OpenCV</a> (Open Source Computer Vision). В ней эффективно реализована необходимая нам функциональность, библиотека бесплатная,  свободная (лицензия BSD), кросс-платформенная и является фактически стандартом в компьютерном зрении &mdash; количество её скачиваний превысило 2 миллиона.</p> 
<p><img src="/images/burnedarea-opencv-01.png" width="100" height=123 hspace=20 align="right">В этой статье мы по шагам рассмотрим как можно использовать библиотеку OpenCV для распознавания сгоревших территорий. Для примера мы будем использовать данные  MODIS на начало и конец лета 2010 года представленными двумя продуктами:
<ul>
	<li><a href="https://lpdaac.usgs.gov/lpdaac/products/modis_products_table/surface_reflectance/8_day_l3_global_500m/mod09a1">MOD09A1</a> &mdash; 8-дневные композиты, содержащие 7 каналов отражающей способности земной поверхности (Surface Reflectance Bands 1–7);</li>
	<li><a href="https://lpdaac.usgs.gov/lpdaac/products/modis_products_table/burned_area/monthly_l3_global_500m/mcd45a1">MCD45A1</a> &mdash; информация о сгоревшей территории с указанием даты пожаров для каждого пикселя местности.</li>
</ul>
<p>Оба этих продукта имеют разрешение 500 метров на один пиксель местности. В качестве тренировочной выборки мы возьмём данные по республике Марий-Эл, а в качестве тестовой &mdash; данные по Нижегородской области. </p>
<p><strong>Оглавление</strong></p>
<ol>
	  <li><a href="#01">Импорт данных MODIS</a></li>
	  <li><a href="#02">Обучение деревьев решений</a></li>
	  <li><a href="#03">Распознавание</a></li>
	  <li><a href="#04">Пост-обработка</a></li>
	  <li><a href="#05">Валидация</a></li>
	  <li><a href="#06">Визуализация</a></li>
	  <li><a href="#07">Экспорт результатов</a></li>
	  <li><a href="#08">Результаты экспериментов</a></li>
</ol>

<h2><strong><a name="01" id="01"></a></strong>1. Импорт данных MODIS</h2>
<p>Прежде всего нужно перевести данные MODIS из формата HDF в GeoTIFF &mdash; про это подробно написано в статье <a href="modisimport.html">Импорт продуктов MODIS уровней 2G, 3, 4 с помощью MRT</a>. После этого мы сможем загрузить данные в OpenCV как обычное изображение в формате GeoTIFF. Поскольку изображение &mdash; это набор яркостей пикселей, то в OpenCV он будет хранится как матрица. Для этого используется класс Mat &mdash; главный класс для работы с матрицами и изображениями в OpenCV:</p>
<pre>Mat modisBand = imread("sur_refl_b01.tif", CV_LOAD_IMAGE_UNCHANGED);
//читаем изображение из файла "sur_refl_b01.tif" и записываем его в матрицу modisBand</pre>
<p>Подгрузив аналогично 7 каналов MODIS на начало лета и 7 каналов на конец лета, мы можем собрать все данные в одну 14-канальную матрицу, то есть прямоугольную матрицу элементами которой являются вектора из 14 элементов:</p>
<pre>vector&lt;Mat&gt; allBands;<br>allBands.push_back(modisBand);<br>... //подгружаем по очереди все каналы и добавляем их в allBands<br>Mat data;<br>merge(allBands, data); //объединяем все каналы в одну матрицу data</pre>
<p>Для обучения деревьев решений и валидации полученных результатов нам необходима информация о том, какие же территории действительно сгорели за это лето. С помощью OpenCV мы легко сможем получить эту информацию из продукта <a href="https://lpdaac.usgs.gov/lpdaac/products/modis_products_table/burned_area/monthly_l3_global_500m/mcd45a1">MCD45A1</a>, используя логические операции между матрицами и скалярами, которые выполняются попиксельно:</p>
<pre>Mat burnDate = imread(burnDateFilename, CV_LOAD_IMAGE_UNCHANGED);<br>//элемент матрицы burnDate содержат информацию о дате пожара, произошедшего в соответствующем пикселе местности<br>Mat unburnedArea = (burnDate == 0);<br>//элемент матрицы unburnedArea будет равен 255, если пиксель не сгорел (дата пожара равна нулю), или 0 в противном случае.<br>uint16_t minBurnDay = 153; //2 июня<br>uint16_t maxBurnDay = 248; //5 сентября   <br>Mat burnedArea = (burnDate &gt;= minBurnDay) &amp; (burnDate &lt;= maxBurnDay);<br>//элемент матрицы burnedArea будет равен 255, если в нём был пожар в указанном диапазоне дат, или 0 в противном случае</pre>

<h2><strong><a name="02" id="02"></a></strong>2. Обучение деревьев решений</h2>
<p>В качестве классификатора можно использовать простой и популярный подход &mdash; дерево решений. Но более точные результаты можно попробовать получить, если использовать <a href="http://ru.wikipedia.org/wiki/Random_forest">ансамбль деревьев решений (Random Forest)</a>, который обобщает народную мудрость "одна голова хорошо, а две лучше". Сейчас данные загружены в виде 14-канальной матрицы. Для тренировки деревьев решений нам нужна 1-канальная матрица, в которой каждая строка &mdash; это один элемент тренировочной выборки, а в столбцах хранятся числовые значения его признаков (соответствующих каналов). То есть нам нужно преобразовать исходную матрицу в 1-канальную матрицу из 14 столбцов, в которой строка соответствует данным MODIS для одного пикселя местности:</p>
<pre>Mat trainData = data.reshape(1, data.total());<br>//сделать из data 1-канальную матрицу с числом строк, равным числу пикселей в data<br>Mat responses = burnedArea.reshape(1, burnedArea.total());<br>//аналогично поступаем с метками классов</pre>
<p>Теперь можем запустить тренировку ансамбля деревьев решений:</p>
<pre>CvRTrees classifier;<br>classifier.train(trainData, CV_ROW_SAMPLE, responses);<br>//СV_ROW_SAMPLE указывает, что элементы выборки для классификации хранятся по строкам</pre>
<p>Совершенно аналогично мы можем натренировать обычное дерево решений для сравнения:</p>
<pre>CvDTree decisionTree;
decisionTree.train(trainData, CV_ROW_SAMPLE, responses);</pre>

<h2><strong><a name="03" id="03"></a></strong>3. Распознавание</h2>
<p>Следующий шаг &mdash; классификация каждого пикселя местности тестовых данных с помощью натренированного ансамбля деревьев решений:</p>
<pre>int rowsCount = testData.rows; <br>//количество строк в матрице testData, равное количеству классифицируемых пикселей местности<br>Mat prediction = Mat(rowsCount, 1, CV_32SC1); <br>//создаём матрицу размера rowsCount x 1 и типом элемента int<br>for(int i=0; i&lt;rowsCount; i++)<br>{<br>  Mat sample = testData.row(i); <br>  //извлекаем i-ую строчку из матрицы testData - значения 14 каналов MODIS для соответствующего пикселя местности<br>  prediction.at&lt;int&gt;(i, 0) = classifier.predict(sample); <br>  //записываем результат классификации в элемент (i, 0) матрицы prediction<br>}</pre>

<h2><strong><a name="04" id="04"></a></strong>4. Пост-обработка</h2>
<p>Деревья решений классифицируют каждый пиксель независимо друг от друга. Это приводит к тому, что хотя все соседи пикселя классифицированы как сгоревшие, он сам может может быть классифицирован как несгоревший &mdash; для реального распространения пожара это маловероятно. Для учёта результатов классификации соседних пикселей можно использовать операции <a href="http://ru.wikipedia.org/wiki/Математическая_морфология">математической морфологии</a>:</p>
<pre><xmp>dilate(predictedBurnedArea, predictedBurnedArea, Mat(), Point(-1, -1), 5); 
//применяем наращивание 5 раз. Используется структурирующий элемент по умолчанию - квадратный элемент 3x3
erode(predictedBurnedArea, predictedBurnedArea, Mat(), Point(-1, -1), 7);
//применяем эрозию 7 раз
dilate(predictedBurnedArea, predictedBurnedArea, Mat(), Point(-1, -1), 3);
//применяем наращивание 3 раза
</xmp></pre>

Результаты обработки (белым цветом показаны сгоревшие территории):
<table align="center" cellspacing="10">
<tr>
  <td><img src="/images/burnedarea-opencv-02.png" width="375" height="245"/></td>
  <td></td>
  <td><img src="/images/burnedarea-opencv-03.png" width="375" height="245"/></td>
</tr>
<tr>
  <td><p align="center">до морфологии</p></td>
  <td></td>
  <td><p align="center">после морфологии</p></td>
</tr>
</table>
</p>


<h2><strong><a name="05" id="05"></a></strong>5. Валидация</h2>
<p>Для оценки качества классификации воспользуемся стандартным подходом &mdash; подсчитаем <a href="error-matrix.html">матрицу ошибок (confusion matrix)</a>. Элемент (i, j) этой матрицы равен количеству объектов класса i, классифицированных как класс j. Матрицу ошибок можно посчитать, имея матрицы с реальными значениями классов (groundTruth) и с предсказанными значениями (prediction):</p>
<pre>int classesCount = 2; //количество распознаваемых классов<br>Mat confusionMatrix(classesCount, classesCount, CV_32SC1); <br>//создаём матрицу размера classesCount x classesCount типа int<br>for(int i=0; i&lt;classesCount; i++)<br>{  <br>  for(int j=0; j&lt;classesCount; j++)<br>  {<br>    confusionMatrix.at&lt;int&gt;(i, j) = countNonZero((groundTruth == i) &amp; (prediction == j)); <br>    //подсчитываем количество элементов класса i, классифицированных как j    <br>  }<br>}</pre>

<h2><strong><a name="06" id="06"></a></strong>6. Визуализация</h2>
<p>Каналам RGB соответствуют каналы 1, 3 и 4 спутника MODIS. Для создания снимка нужно объединить эти каналы в одно изображение. Для повышения качества полученного изображения с ним нужно сделать несложные преобразования, описанные в статье <a href="/docs/modis_true_color.pdf">Creating Reprojected True Color MODIS Images: A Tutorial</a>. После этого отрисуем контуры сгоревших территорий поверх полученного изображения:</p>
<pre>
</xmp>vector&lt;vector&lt;Point&gt;&gt; contours; <br>//массив для найденных контуров <br>findContours(burnedArea, contours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE); <br>//найти контура по маске сгоревших территорий<br>drawContours(trueColorImage, contours, -1, Scalar(0, 0, 255), 2); <br>//нарисовать все контуры красной линией толщины 2<br>namedWindow(&quot;burned area contours&quot;, CV_WINDOW_NORMAL); <br>//создать окно c именем &quot;burned area contours&quot;<br>imshow(&quot;burned area contours&quot;, trueColorImage); <br>//отобразить изображение в созданном окне<br>waitKey();<br>//отображать изображение, пока пользователь не нажмёт &quot;any key&quot;</pre>

<h2><strong><a name="07" id="07"></a></strong>7. Экспорт результатов</h2>
<p>Для экспорта результатов в GeoTIFF сначала сохраним полученное изображение в формате TIFF:</p>
<pre><xmp>imwrite("burnedArea.tif", trueColorImage);</xmp></pre>
<p>Теперь сохранённое изображение нужно связать с географическими координатами. Для этого есть несколько способов, в том числе есть и хорошие решения &mdash; кросс-платформенные, бесплатные и с открытым исходным кодом. Например, можно использовать библиотеку GDAL &mdash; про это подробно написано в статье <a href="georef-gdal.html">Использование GDAL для привязки растровых материалов</a>. </p>

<h2><strong><a name="08" id="08"></a></strong>8. Результаты экспериментов</h2>
<p>Для повышения точности классификации помимо описанных шагов лучше добавить ещё несколько дополнительных фильтров (например, фильтрация данных по качеству и тренировка классификатора только на надёжных данных). Полную версию алгоритма с данными и исходным кодом можно скачать <a href="/other/burnedarea-opencv.zip">здесь</a>. Теперь мы можем визуально оценить результаты работы алгоритма:</p>
<p align="center"><img src="/images/burnedarea-opencv-04.png" width="460" height="300"/><br/>Найденные контура сгоревших территорий (синусоидальная проекция)</p>
<p>Количественную оценку дают построенные матрицы ошибок:</p>
<table align="center" border="1">
  <caption>Матрица ошибок для одного обычного дерева решений</caption>
  <tr> 
    <th colspan="2"></th>
    <th colspan="2">Предсказанный класс территории</th></tr>
  <tr>	
    <th colspan="2"></th>
	<th>Несгоревшая</th>
	<th>Сгоревшая</th>
  </tr>
  <tr>
    <th rowspan="2">Реальный класс территории</th>
	<th>Несгоревшая</th>
	<td><p align="center">109423</p></td>
	<td><p align="center">17387</p></td>	
  </tr>
  <tr>
    <th>Сгоревшая</th>
    <td><p align="center">60</p></td>
    <td><p align="center">3372</p></td>
  </tr>
</table>
</p>
<br/>
<table align="center" border="1">
  <caption>Матрица ошибок для ансамбля деревьев решений</caption>
  <tr> 
    <th colspan="2"></th>
    <th colspan="2">Предсказанный класс территории</th></tr>
  <tr>	
    <th colspan="2"></th>
	<th>Несгоревшая</th>
	<th>Сгоревшая</th>
  </tr>
  <tr>
    <th rowspan="2">Реальный класс территории</th>
	<th>Несгоревшая</th>
	<td><p align="center">120367</p></td>
	<td><p align="center">6443</p></td>	
  </tr>
  <tr>
    <th>Сгоревшая</th>
    <td><p align="center">172</p></td>
    <td><p align="center">3260</p></td>
  </tr>
</table>
</p>
<p>Рассчитаем ошибки <a href="error-matrix.html">омиссии и комиссии:</a></p>

<table align="center" border="1">
  <caption>Ошибки классификаторов</caption>
  <tr> 
    <th colspan="2"></th>
    <th colspan="2">Классификатор</th></tr>
  <tr>	
    <th colspan="2"></th>
	<th>Дерево решений</th>
	<th>Ансамбль деревьев решений</th>
  </tr>
  <tr>
    <th rowspan="2">Ошибка</th>
	<th>омиссии</th>
	<td><p align="center">0.02</p></td>
	<td><p align="center">0.05</p></td>	
  </tr>
  <tr>
    <th>комиссии</th>
    <td><p align="center">0.84</p></td>
    <td><p align="center">0.66</p></td>
  </tr>
</table>
</p>
<p>Используя ансамбль деревьев решений, мы нашли 95% случившихся пожаров, но при этом 66% территорий, классифицированных как сгоревшие, относятся к несгоревшим по данным MCD45, которые в свою очередь отличаются большой ошибкой омиссии (<a href="mcd45.html">Данные о сгоревших площадях MCD45: описание и получение</a>).</p> 
<p>Не менее важной характеристикой алгоритма является время его работы. На Intel Core i7 960 @ 3.20GHz с использованием только одного потока время тренировки ансамбля деревьев решений составило 0.85 секунды (54000 пикселей), время обработки тестовой территории &mdash; 0.13 секунды (130 000 пикселей).</p>
<p>Таким образом, используя стандартные средства OpenCV, мы смогли легко получить простой и быстрый алгоритм для распознавания сгоревших территорий.
  <!-- обсуждение на форуме, цифра изменяется при публикации статьи -->   
</p>

<p class="discuss"><span><!--#include virtual="/scripts/forum-comments-num.php?i=7554"--></span></p>
<!-- ссылки -->
<div class="links">
	<h2>Ссылки по теме</h2>
		<ul>					
			<li><a href="http://opencv.willowgarage.com" target="_blank" class="external">Библиотека компьютерного зрения OpenCV</a></li>
			<li><a href="mcd45.html">Данные о сгоревших площадях MCD45: описание и получение</a></li>
			<li><a href="firms.html">Мониторинг пожаров на природных территориях с помощью сервиса FIRMS</a></li>
		</ul>
</div>
<!--Contents end-->
<!--#include virtual="/scripts/date.php" -->
<p class="status"><span>Дата создания: 31.03.2011
<br>Автор(ы): <a href="http://twitter.com/ilysenkov" target="_blank">Илья Лысенков</a> (инженер по программному обеспечению, <a href="http://itseez.com/" target="_blank">Itseez</a>)</span></p>
<!--#include virtual="/inc/footer2.php" -->